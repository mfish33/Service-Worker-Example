{"version":3,"sources":["webpack:///webpack/bootstrap 08a481d56a088c6ac541?0e82","webpack:///./src/sharedTypes.ts?d1b7","webpack:///./src/workerToHost-Host.ts","webpack:///./~/promise-worker/index.js","webpack:///./src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 08a481d56a088c6ac541","export interface crossThreadMessage {\r\n    header: string\r\n    body: any\r\n}\r\n\r\nexport interface workerHostFuncCall extends crossThreadMessage {\r\n    body: {\r\n        func: string\r\n        args: any[]\r\n    }\r\n}\r\n\r\nexport enum Status {\r\n    error = 'error',\r\n    success = 'success',\r\n    init = 'init'\r\n}\r\n\r\nexport interface HostFuncRes extends crossThreadMessage {\r\n    body: {\r\n        status: Status,\r\n        return: any\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/source-map-loader!./src/sharedTypes.ts","import PromiseWorkerType from 'promise-worker'\r\nimport { workerHostFuncCall, HostFuncRes, Status } from './sharedTypes'\r\n\r\nexport default class WorkerToHost {\r\n\r\n    private serviceWorker: PromiseWorkerType\r\n    private funcRegistry = {}\r\n\r\n    constructor() {\r\n        this.funcRegistry = {}\r\n    }\r\n\r\n    public registerFunc(func: Function, name?: string) {\r\n        const funcName = name ? name : func.name\r\n        if (this.funcRegistry[funcName]) {\r\n            throw 'Naming Conflict in register Function'\r\n        }\r\n        this.funcRegistry[funcName] = func\r\n    }\r\n\r\n    public registerServiceWorker(serviceWorker: PromiseWorkerType): void {\r\n        if (this.serviceWorker) {\r\n            throw 'Service Worker Already Registered'\r\n        }\r\n        this.serviceWorker = serviceWorker\r\n        serviceWorker.postMessage(\r\n            {\r\n                header: 'WorkerToHost',\r\n                body: {\r\n                    status: Status.init\r\n                }\r\n            } as HostFuncRes\r\n        ).then((message) => this.handleResponse(message))\r\n    }\r\n\r\n    private handleResponse(res: workerHostFuncCall): void {\r\n        if (res.body.func == '__echo__init') {\r\n            return\r\n        }\r\n        let possibleFunc = this.funcRegistry[res.body.func]\r\n        if (possibleFunc) {\r\n            try {\r\n                Promise.resolve(possibleFunc(...res.body.args)).then(ret => this.reHook(Status.success, ret))\r\n            } catch (e) {\r\n                this.reHook(Status.error, e)\r\n            }\r\n        } else {\r\n            this.reHook(Status.error, 'Function is not currently Registered')\r\n        }\r\n    }\r\n\r\n    private reHook(status: Status, returnVal: string) {\r\n        this.serviceWorker.postMessage(\r\n            {\r\n                header: 'WorkerToHost',\r\n                body: {\r\n                    status: status,\r\n                    return: returnVal\r\n                }\r\n            } as HostFuncRes\r\n        ).then((message) => this.handleResponse(message))\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/source-map-loader!./src/workerToHost-Host.ts","'use strict'\n\nvar messageIds = 0\n\nfunction onMessage (self, e) {\n  var message = e.data\n  if (!Array.isArray(message) || message.length < 2) {\n    // Ignore - this message is not for us.\n    return\n  }\n  var messageId = message[0]\n  var error = message[1]\n  var result = message[2]\n\n  var callback = self._callbacks[messageId]\n\n  if (!callback) {\n    // Ignore - user might have created multiple PromiseWorkers.\n    // This message is not for us.\n    return\n  }\n\n  delete self._callbacks[messageId]\n  callback(error, result)\n}\n\nfunction PromiseWorker (worker) {\n  var self = this\n  self._worker = worker\n  self._callbacks = {}\n\n  worker.addEventListener('message', function (e) {\n    onMessage(self, e)\n  })\n}\n\nPromiseWorker.prototype.postMessage = function (userMessage) {\n  var self = this\n  var messageId = messageIds++\n\n  var messageToSend = [messageId, userMessage]\n\n  return new Promise(function (resolve, reject) {\n    self._callbacks[messageId] = function (error, result) {\n      if (error) {\n        return reject(new Error(error.message))\n      }\n      resolve(result)\n    }\n\n    /* istanbul ignore if */\n    if (typeof self._worker.controller !== 'undefined') {\n      // service worker, use MessageChannels because e.source is broken in Chrome < 51:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=543198\n      var channel = new MessageChannel()\n      channel.port1.onmessage = function (e) {\n        onMessage(self, e)\n      }\n      self._worker.controller.postMessage(messageToSend, [channel.port2])\n    } else {\n      // web worker\n      self._worker.postMessage(messageToSend)\n    }\n  })\n}\n\nmodule.exports = PromiseWorker\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise-worker/index.js\n// module id = 7\n// module chunks = 1","import PromiseWorkerType from 'promise-worker'\r\nconst PromiseWorker = require('promise-worker')\r\nimport WorkerToHost from './workerToHost-Host'\r\nconst workerToHost = new WorkerToHost()\r\n\r\nlet Pworker: Promise<PromiseWorkerType> = navigator.serviceWorker\r\n    .register('sw.js', { scope: '/' })\r\n    .then(waitForServiceWorkerActivation)\r\n    .then(worker => {\r\n        let PW = new PromiseWorker(worker as any)\r\n        workerToHost.registerServiceWorker(PW)\r\n        return PW\r\n    })\r\n    .catch(e => console.error('There was an error registering the Service Worker please restart the app', e))\r\n\r\n\r\nasync function waitForServiceWorkerActivation(registration: ServiceWorkerRegistration): Promise<ServiceWorkerContainer> {\r\n    if (navigator.serviceWorker.controller) { // already active and controlling this page\r\n        return navigator.serviceWorker;\r\n    }\r\n    return new Promise(resolve => {\r\n        registration.addEventListener('updatefound', () => {\r\n            let newWorker = registration.installing;\r\n            newWorker.addEventListener('statechange', () => {\r\n                if (newWorker.state == 'activated' && navigator.serviceWorker.controller) {\r\n                    resolve(navigator.serviceWorker);\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\nworkerToHost.registerFunc(() => 'Hello from the mainThread', 'test')\n\n\n// WEBPACK FOOTER //\n// ./~/source-map-loader!./src/index.ts"],"sourceRoot":""}